#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#define MALLOC(p,s)\
if (!((p) = malloc(s))){\
   printf("error");\
   fprintf(stderr, "Insufficient memory");\
   exit(EXIT_FAILURE);\
}

typedef struct polyNode* polyPointer;
typedef struct polyNode {
    int coef;
    int expo;
    polyPointer link;
}PolyNode;

polyPointer a, b;

//void find(polyPointer a, int m); //insert의 위치 찾기(insert와 통합 가능)
void insert(polyPointer* a, int m, int n); // 새로운 값을 다항식에 입력
void mergeList(polyPointer* a, polyPointer* b); // 두 다항식을 합침(a에 b를)
//void reverseList(polyPointer* a); // 다항식을 역순정렬
void subt(polyPointer a, int var); // 다항식에 상수 대입
void sort(polyPointer* temp);
void swapNode(polyPointer a, polyPointer b);
void printList(polyPointer a);

int main(void)
{
    int ac, ae, bc, be; //ac: a 계수, ae: a 차수, bc: b 계수, be: b 차수
    ac = ae = bc = be = 1;
    int var; //var: 변수 X의 값

    printf("Enter A node coef & exponent\n");
    while ((ac != 0) || (ae != 0)) //0 0 입력할 시 종료
    {
        scanf("%d %d", &ac, &ae);
        //find(a, ae);
        insert(&a, ac, ae);
    }
    sort(&a);

    printf("Enter B node coef & exponent\n");
    while ((bc != 0) || (be != 0)) //0 0 입력할시 종료
    {
        scanf("%d %d", &bc, &be);
        // find(b, be);
        insert(&b, bc, be); //입력받은 bc, be의 값을 다항식 b에 정렬하는 과정
    }
    sort(&b);

    //printf("입력한 다항식을 확인합니다.\n");
    printf("A : "); printList(a); //printpol:다항식 출력
    printf("B : "); printList(b);

    printf("다항식 A와 B를 합합니다.\n");
    mergeList(&a, &b); //다항식 a에 다항식 b를 더하는 방식(a에 저장)
 //   reverseList(&a); //리스트 역순 정렬
    printf("A + B : "); printList(a); //b를 더한 a를 출력

    printf("Enter X:\n");
    scanf("%d", &var); //대입 상수 입력받음
    subt(a, var); //다항식 a에 대입 상수 var을 대입, 출력

    return 0;
}

void insert(polyPointer* a, int m, int n)
{
    polyPointer temp, newNode;
    MALLOC(temp, sizeof(*temp));
    MALLOC(newNode, sizeof(*newNode));
    temp = *a;
    newNode->coef = m;
    newNode->expo = n;
    newNode->link = NULL;
    if (*a) {
        for (;;) {
            if (temp->link == NULL)
                break;
            temp = temp->link;
        }

        temp->link = newNode;
    }
    else {
        newNode->link = NULL;
        *a = newNode;
    }
}

void mergeList(polyPointer* a, polyPointer* b) {

    polyPointer beforea, tempa, tempb;
    tempa = *a;//a리스트에 접근하기 위함
    tempb = *b;//b리스트에 접근하기 위함
    beforea = *a;//tempb를 a에 연결하기 위해 앞에 순서 접근
    int i = 0;//beforea를 tempa보다 하나 늦추기 위한 i
    while (tempa != NULL && tempb != NULL) {
        if (tempb != NULL && (tempa)->expo > (tempb)->expo) {//a의 차수가 큰 경우
            tempa = (tempa)->link;
            i++;
            if (i != 0) {//beforea를 tempa보다 하나 늦추기 위한 i
                beforea = beforea->link;
            }
        }
        else if ((tempa)->expo < (tempb)->expo) {//b의 차수가 큰 경우
            polyPointer tempb2;//tempb를 넣으면 b의 다음 순서에 접근이 불가하기 때문에 똑같은 tempb2를 생성
            MALLOC(tempb2, sizeof(*tempb2));
            tempb2->coef = (tempb)->coef;
            tempb2->expo = (tempb)->expo;
            tempb2->link = (tempa);//a의 사이에
            beforea->link = tempb2;//tempb2를추가
            if (i != 0) {//beforea를 tempa보다 하나 늦추기 위한 i
                beforea = beforea->link;//하나가 더 가야(tempb2로 가는 것) 다음 순서에 그 다음 a에 접근이 가능
            }
            (tempb) = (tempb)->link;
        }
        else {//차수가 같은 경우
            tempa->coef = tempa->coef + tempb->coef;

            tempa = tempa->link;
            if (i != 0) {//beforea를 tempa보다 하나 늦추기 위한 i
                beforea = beforea->link;
            }
            i++;
            tempb = tempb->link;
        }
    }
}

void subt(polyPointer a, int var) {
    double num = (double)var;
    double sum = 0;

    for (; a; a = a->link) {
        sum += (double)(a->coef) * pow(num, (double)a->expo);
        printf("%d*%d^%d ", a->coef, var, a->expo);
    }
    printf("\n%d", (int)sum);
}

void sort(polyPointer* temp) {
    polyPointer temp1, temp2;
    MALLOC(temp1, sizeof(*temp1));
    MALLOC(temp2, sizeof(*temp2));
    temp1 = *temp;//앞에 노드
    //앞의 노드를 i에 고정시키고 i+1부터 돌면서 i번째와 비교할 노드
    for (int i = 0; temp1; temp1 = temp1->link, i++) {//리스트 i번째(첫번째부터)에 가장 낮은 수의 노드 보내기
        temp2 = temp1->link;
        for (int j = i; temp2; j++, temp2 = temp2->link) {//
            if (temp1->expo < temp2->expo) {
                swapNode((temp1), (temp2));//tmep1,temp2 데이터 swap
            }
        }
    }
}

void swapNode(polyPointer temp1, polyPointer temp2) {
    polyPointer temp;
    MALLOC(temp, sizeof(*temp));

    temp->link = (temp1)->link;
    (temp1)->link = (temp2)->link;
    (temp2)->link = temp->link;

    *temp = *temp1;
    *temp1 = *temp2;
    *temp2 = *temp;
}

void printList(polyPointer a) {
    for (; a; a = a->link) {
        if (a->coef != 0) {
            if (a->link->link != NULL)
                printf("%dx^%d +", a->coef, a->expo);
            else
                printf("%dx^%d", a->coef, a->expo);
        }
    }
    printf("\n");
}
